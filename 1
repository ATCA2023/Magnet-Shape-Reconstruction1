Pre-read

Hello. We are sorry for making you open this file but we felt that the program was already too big and any explanation in-program wouldn't help as it'd be quite hard to 
understand.

Which is why we made this file - to aid everyone looking for magnet reconstruction algorithms or simply trying to understand the program. We are once again apologizing for the
inconvenience.

Also, this document was indented for better GitHub view so if it looks weird, try resizing (maximize the tab) the text viewer or simply read it at:
https://github.com/ATCA2023/Magnet-Shape-Reconstruction1/blob/main/READ%20ME%20-%20a%20concise%20explanation%20of%20the%20algorithms%20created%20and%20used.txt

Let's start with the explanations now.
#######################################################################################

This algorithm only works efficiently for full magnets. Holes in the magnet and multiple magnets might mean the need of billions of points for accurate reconstructions
or simply getting inaccurate results.


I.1: Data used.			//////

Our reconstruction algorithm is based on 2 known things about our magnet:

K.1) The magnetic field intensity value at any location (negative if it's going into the magnet and positive if the field line's coming from the magnet. 
The intensity on all 3 axes combined.)

K.2) The x y z cartesian space coordinates of all those measurements.



I.2: The way it's working	//////

Before starting, we first have to account for a couple of things. 

C.1) We assume the magnet is constructed out of very small dipoles. The reasoning is simple: The field lines come from the North Pole and go into the South Pole.
Also, if you ever played with magnets, you know that by sticking 2 magnets together (North of magnet 1 to South of magnet 2), you create a bigger, stronger magnet.
That being said, a dipole has enough poles to be a magnet on its one (2 poles) but can also be added to another dipole, creating a stronger and bigger magnet.

C.2) All dipoles have the same orientation. All magnets must have mostly the same electron spin orientation in order for the generated fields to 
add up, but there are usually a few discrepancies. Unfortunately, it already takes quite a long time to run the program with no guarantee of it actually
giving precise results unless you perfectly guessed the values of the trial-and-error variables, as we call them (We'll get into that later) which is why we will 
consider that all the dipoles have the same orientation in space represented by the x=y=0 equation (perpendicular on the xy plane).

Having that taken into consideration, we can now finally start explaining the main algorithm.

Let's talk about the logic first. The idea everything revolves around is that a field generated by such a magnet must be unique. Therefore, by starting
with a magnet shape guess that's smaller than the shape of the actual magnet and creating very small bumps on its surface (the magnet guess's surface)
where the recorded field data is greater than the simulated magnet guess data, our magnet guess should start to resemble the real magnet more and more precisely.

But we can't just bump the surface of a magnet in a computer program efficiently. That's why we chose a similar approach. We started with a sphere shaped 
magnet guess since the sphere has the smallest volume of all full shapes and it also provides the same first shape guess for all recorded points 
(In our case, we already knew the approximate radius so we used 1000 considering the probable extension of the points in space). Then, instead of 
bumping the surface, we predefined a linear equation for each dipole: A linear equation that passes through 2 points one being the dipole's x y z space coordinates 

and the other one being the magnet's center in 0 0 0 (For enough dipoles, this method should provide very good approximations) and started adding the dipoles
towards or away from the center of the magnet. The distance we are adding the new dipoles is going to be calculated using a variable called scale. 
The bigger the scale, the faster the program will be but less accurate. Too small of a scale will provide hardly noticeable results since the dipoles will be generating 
a strong field because of their large number in a rather small area.



Now that we've presented the overview, let's get into the details.

We already talked earlier about how we will put a number of dipoles on a spherical surface pattern and extend each of those dipoles along its linear equation.
But if we think about how every place around a magnet works, we realize that there are most of the places like the North Pole which should be overall 
constantly influenced by the positive dipoles only. Same applies to the South Pole. But what about the area between the 2 Poles? Normally, it should be 
constantly 0 for 2 symmetric poles, but since we want an accurate reconstruction, they won't be the same. How do we know if that values are influenced 
by positive dipoles, negative dipoles or a combination of the 2? Our answer was to run an analysis on the influenceability of the dipoles. 
Basically, before we started the actual reconstruction, we extended each dipole in space by a small scale, until one of the dipoles exited the recorded measurements area.
While doing that, we recorded the number of sign changes of those points over time and what dipole caused the sign change in a matrix we like to call 
the dipole changeability matrix.

The rest is simple: We extend each dipole once by a correct, small scale. If we have a dipole that after analysation, we know doesn't change any measurement's sign 
but it is now about to, it means the current magnet's shape guess has reached its maximum accuracy for the current scale on the side of that dipole, 
so we fix that dipole in place. If it's a dipole that can't be fixed (changed a measurement's sign more than once), we will simply extend it without considering 
its effects on the recorded measurements (It can't affect a non-changing sign measurement since it's a moving dipole we found earlier while running the analysis).

 After all dipoles that can be fixed are stopped from moving on their linear equation, we'll move onto the mobile ones. Here, we'll find the order we'll extend 
each of them by looking at how many measurement points they are influencing. We'll sort them by measurements (signwise) influenced by the smallest number of dipoles 
to max number and then dipoles influencing the least amount of measurements to the highest amount. The reason is that a less influenced measurement should be the first
we should try to take to 0 against a more influenced one since it will be harder because we have less dipoles to do so. Don't forget we want to take all the measurements 
as close to 0 as possible at the same time. As for the dipoles, if it influences less measurements it's very likely that the dipole will have a bigger impact 
on each of them than a dipole influencing a very big number of measurements. After getting this order, we run the dipoles along their respective equations while
trying to take as many measurements closer to 0 as possible and we will stop when we realize we are not modifying any of the measurements anymore. 
Note that in this last step, only the moving dipoles with the same sign as the measurements trying to influence will be moved.




I.3: Creating the final algorithm's steps by adding all the information above:


Step 1: Arrange the dipoles on a spherical surface that is as big as possible while still making sure that the sphere can fit inside the actual magnet.

Step 2: Run the analysis to find which recorded measurements are influenced by multiple different sign dipoles 
(As we expected, we found out that those recorded points were the ones closer to Earth's equatorial line.)

Step 3: Start reconstruction. Move each dipole that doesn't influence the signs of any recorded point until all such dipoles can't be moved without the current 
magnet's field simulation exiting the recorded field of the actual magnet. For the rest of the dipoles that do influence the signs of the recordings 
multiple times, simply extend them as long as they don't exit the reconstruction size (the measurements).

Step 4: Sort the remaining measurements (the ones that change sign) from the ones that have the least number of unfixed dipoles influencing them 
(that changed their sign in the past) to the ones that have the most number of dipoles influencing them and do the same for those dipoles that haven't been fixed 
yet: sort them from the ones influencing the least number of recorded measurements to the one influencing the highest number of recordings. Then, using 
the first sorted array (the readings one), make another array that contains the sorted dipoles in the sorted array appearance. Remove dipoles that 
were already part of the ordered array since one cycle includes all dipoles only once.

Step 5: Repeat everything for a smaller scale on the results obtained or output the result.



Here's a small example for a better understanding of Step 4:


After Step 3 analysis, we get the next changeability matrix (1 represents influenced recording sign and 0 means it's a non-influenced one)


		Measurement 1	Measurement 2	Measurement 3:	Measurement 4:		No. measurements influenced by dipole

Dipole 1:	     0		      1		      1		     1			-3

Dipole 2:	     1		      0		      1		     0			-1

Dipole 3:	     1		      1		      1		     0			-3

Dipole 4:	     0		      0		      0		     1			-1

Dipole 5:	     0		      0		      0		     0			-0


		     |		      |		      |		     |	
No. dipoles	     2		      2		      3		     2	
influencing measurements



Looking at the example above, we notice that Dipole 5 is a fixed dipole since it doesn't influence any measurement.

The 2 sorted arrays (containing the indices) will be:

Measurement vector: 1 2 4 3 (influenced 2 2 2 3 times)
Dipole vector: 2 4 1 3 (with 1 1 3 3 influenced measurements)

The vector order: The first measurement in the measurement vector, position 1 is influenced by dipole 2 and 3. In the dipole vector, 2 comes before 3, so
that's the first 2 elements of the current vector. The second measurement: Dipole 1 and 3 in this order. Measurement 4 is next: 1 and 4 which 
becomes 4 and 1. Measurement 3: Dipole 1 2 3. This one's order according to the Dipole vector is 2 1 3.

Combining everything, we get 2 3  1 3  4 1  2 1 3. Since the dipoles must all extend once per cycle, we remove the duplicates and we get the 
correct order used to extend our remaining dipoles: 2 3 1 4. (Those numbers represent the dipole's indices).






This is the program's algorithm explained. We hope you found it useful and while you're free to use it or change it to your heart, we politely ask 
you to at least mention our team's name and the first place this little algorithm blossomed ( like this, for example ): " Developed by team ATCA, 
Astro Pi 2022-2023 " in anything that you wish to include it in because we put a lot of time, love and effort in the making of it. 


We wish you good luck with your current task and we only hope for the best in your future!
											   -ATCA, 2023

And until the end, remember, “It does not matter how slowly you go as long as you do not stop.” - Confucius

