#include <iostream>
#include <fstream>
#include <cmath>
#include <Eigen/Core>
#include <Eigen/Dense>
#include <vector>
#include <iomanip>
#include <bitset>
#include <limits>
#include <chrono>

using namespace std;

#define isinsiderecorded (surfacePoint.x > maxX || surfacePoint.x < minX || surfacePoint.y > maxY || surfacePoint.y < minY ||surfacePoint.z > maxZ || surfacePoint.z < minZ)
#define Signchange ((recordedPoint.intensity > 0 && recordedPoint.intensity < modifiedIntensities[j]) || (recordedPoint.intensity < 0 && recordedPoint.intensity > modifiedIntensities[j]))
const int recordsize = 210000;

struct SurfacePoint
{
    double x, y, z;
};

struct DataPoint
{
    double x, y, z;
    double intensity; // Magnetic intensity
    double latitude;
};

// Compute the magnetic field generated by an infinitely small dipole at a given position (x, y, z)
double computePointField(const SurfacePoint& dipolePoint, const Eigen::Vector3d& position)
{
    // Constants
    double magneticMoment = 2 * 1e22;  // Magnetic moment of the dipole (assuming a constant value)
    double dipoleSeparation = 0.0001;  // Separation distance between positive and negative poles of the dipole

    // Calculate the distances from the dipole's positive and negative poles
    double distancePositive = (position - Eigen::Vector3d(dipolePoint.x, dipolePoint.y, dipolePoint.z + dipoleSeparation)).norm();
    double distanceNegative = (position - Eigen::Vector3d(dipolePoint.x, dipolePoint.y, dipolePoint.z - dipoleSeparation)).norm();

    // Calculate the magnetic field components from the positive and negative poles
    double fieldPositive = (1e-7 * magneticMoment) / (distancePositive * distancePositive * distancePositive);
    double fieldNegative = (1e-7 * magneticMoment) / (distanceNegative * distanceNegative * distanceNegative);

    // Calculate the net magnetic field at the given position
    double field = fieldPositive - fieldNegative;

    // Return the resulting magnetic field intensity
    return field;
}

// Rotate the recorded data by the specified angles
void rotateRecordedData(std::vector<DataPoint>& recordedData, double angleX, double angleY, double angleZ)
{
    double angleXRad = angleX;
    double angleYRad = angleY;
    double angleZRad = angleZ;

    // Create rotation matrices for each axis
    Eigen::Matrix3d rotationX, rotationY, rotationZ;
    rotationX = Eigen::AngleAxisd(angleXRad, Eigen::Vector3d::UnitX());
    rotationY = Eigen::AngleAxisd(angleYRad, Eigen::Vector3d::UnitY());
    rotationZ = Eigen::AngleAxisd(angleZRad, Eigen::Vector3d::UnitZ());

    // Apply the rotations to each recorded data point
    for (auto& dataPoint : recordedData)
    {
        // Create a 3D vector from the data point coordinates
        Eigen::Vector3d point(dataPoint.x, dataPoint.y, dataPoint.z);

        // Apply the rotations to the point
        point = rotationX * rotationY * rotationZ * point;

        // Update the data point coordinates with the rotated values
        dataPoint.x = point.x();
        dataPoint.y = point.y();
        dataPoint.z = point.z();
    }
}

std::vector<double> calculateFinalCoordinates(double x0, double y0, double z0, double intensity, double angleY, double angleZ)
{
    // Calculate direction vector
    double dx = cos(angleY) * cos(angleZ);
    double dy = sin(angleY) * cos(angleZ);
    double dz = sin(angleZ);

    // Calculate final coordinates
    double xf = x0 + intensity * dx;
    double yf = y0 + intensity * dy;
    double zf = z0 + intensity * dz;

    return { xf, yf, zf };
}


void calculateAngles(double x0, double y0, double z0, double x, double y, double z, double& angleX, double& angleY, double& angleZ)
{
    // Calculate the direction vector of the line
    double directionX = x - x0;
    double directionY = y - y0;
    double directionZ = z - z0;

    // Calculate the angles with the x, y, and z axes
    angleX = std::atan2(directionY, directionZ);
    angleY = std::atan2(directionZ, directionX);
    angleZ = std::atan2(directionY, directionX);
}

void calculateDipoleOrientation(std::vector<DataPoint>& DataPoints)
{
    double x0 = 1e-150;
    double y0 = 1e-150;
    double z0 = 1e-150;

    std::vector<double> compassOrientation = { x0, y0, z0 };  // Initialize compassOrientation

    for (const DataPoint& DataPoint : DataPoints)
    {
        double angleY = std::atan( DataPoint.y  / DataPoint.x );
        double angleZ = std::atan( DataPoint.z / std::sqrt(DataPoint.x * DataPoint.x + DataPoint.y * DataPoint.y) );

        compassOrientation = calculateFinalCoordinates(compassOrientation[0], compassOrientation[1], compassOrientation[2], DataPoint.intensity, angleY, angleZ);
    }

    double anglex,angley,anglez;

    calculateAngles(x0,y0,z0,compassOrientation[0],compassOrientation[1],compassOrientation[2],anglex,angley,anglez);

    rotateRecordedData(DataPoints,0,-M_PI/2+angley-0.00275,-anglez);

}

// Read data from a file and populate the recordedPoints vector
void readDataFromFile(const string& filename, vector<DataPoint>& recordedPoints)
{
    cout << "Reading data from file '" << filename << "' \n";

    ifstream file(filename);
    if (!file)
    {
        cerr << "Error opening file: " << filename << endl;
        return;
    }

    double x, y, z, intensity, latitude, bx, by, bz;

    while (file >> x >> y >> z >> bx >> by >> bz >> latitude)
    {
        double intensity = sqrt(bx * bx + by * by + bz * bz);
        if (bz < 0)
            intensity *= -1;
        latitude *= M_PI / 180;

        recordedPoints.push_back({x, y, z, intensity, latitude});
    }

    cout << "Data read.\nStarting initial radius calculation...\n";

    file.close();
}


// Write precalculated fields to a file
void writePrecalculatedFieldsToFile(const string& filename, const vector<double>& precalculatedFields)
{
    ofstream file(filename);
    if (!file)
    {
        cerr << "Error opening file: " << filename << endl;
        return;
    }

    for (const double& field : precalculatedFields)
    {
        file <<setprecision(30)<< field << "\n";
    }
    file<<setprecision(10);

    file.close();
}

// Read precalculated fields from a file
void readPrecalculatedFieldsFromFile(const string& filename, vector<double>& precalculatedFields)
{
    ifstream file(filename);
    if (!file)
    {
        cerr << "Error opening file: " << filename << "\n";
        return;
    }

    double field;
    while (file >> field)
    {
        precalculatedFields.push_back(field);
    }
    cout<<"Fields read.\n";


    file.close();
}

// Write refined points to a PLY file
void writeRefinedPointsToPLY(const string& filename, const vector<SurfacePoint>& refinedPoints)
{
    ofstream file(filename);
    if (!file)
    {
        cerr << "Error opening file: " << filename << "\n";
        return;
    }

    file << "ply" << endl;
    file << "format ascii 1.0" << endl;
    file << "element vertex " << refinedPoints.size() << endl;
    file << "property float x" << endl;
    file << "property float y" << endl;
    file << "property float z" << endl;
    file << "end_header" << endl;

    for (const SurfacePoint& point : refinedPoints)
    {
        file << point.x << " " << point.y << " " << point.z << endl;
    }

    file.close();
}

double log_a_to_base_b(double b, double a)
{
    return log10(a) / log10(b);
}

int compareBitsets(const std::bitset<recordsize>& bitset1, const std::bitset<recordsize>& bitset2)
{
    for (int i = recordsize - 1; i >= 0; --i)
        if (bitset1[i] != bitset2[i])
            return bitset1[i] ? 1 : -1;

    return 0;
}

int main()
{
    vector<DataPoint> recordedPoints;
    vector<SurfacePoint> surfacePoints;

    double dipolemoment = 6.4*1e24;

    // Read data from file
    readDataFromFile("data.txt", recordedPoints);
    calculateDipoleOrientation(recordedPoints);

    // Step 1:Start from the smallest radius guess us possible since we can't approximate the initial radius
    // We'll also calculate the min and mox of the x y z
    double smallestRadius=1000;

    double maxX=0,maxY=0,maxZ=0,minX=0,minY=0,minZ=0;

    maxX = maxY = maxZ = numeric_limits<double>::lowest();
    minX = minY = minZ = numeric_limits<double>::max();

    for (const DataPoint& point : recordedPoints)
    {
        minX = min(minX, point.x);
        minY = min(minY, point.y);
        minZ = min(minZ, point.z);
        maxX = max(maxX, point.x);
        maxY = max(maxY, point.y);
        maxZ = max(maxZ, point.z);
    }

    // Step 2: Generate points on the surface of the initial spherical magnet
    int numPoints = 1000; // Adjust the number of points as needed
    cout<<"Generating "<<numPoints<<" points in a sphere pattern to start the reconstruction...\n";

    numPoints = static_cast<int>(sqrt(numPoints));

    for (int i = 0; i < numPoints; ++i)
    {
        double theta = M_PI * i / numPoints;
        for (int j = 0; j < numPoints; ++j)
        {
            double phi = 2 * M_PI * j / numPoints;

            double x = smallestRadius * sin(theta) * cos(phi);
            double y = smallestRadius * sin(theta) * sin(phi);
            double z = smallestRadius * cos(theta);

            surfacePoints.push_back({x, y, z});
        }
    }

    string initialPointsFilename = "initial_points.ply";
    writeRefinedPointsToPLY(initialPointsFilename, surfacePoints);

    cout<<"Points generated\n";

    string precalculatedFilename = "precalculated.txt";
    vector<double> precalculatedFields(recordedPoints.size(), 0.0);

    // Check if precalculated fields exist in the file
    bool precalculatedExists = false;
    ifstream precalculatedFile(precalculatedFilename);
    if (precalculatedFile)
    {
        cout<<"Reading precalculated fields from '"<<precalculatedFilename<<"' \n";
        // Read precalculated fields from file
        readPrecalculatedFieldsFromFile(precalculatedFilename, precalculatedFields);
        precalculatedExists = true;
    }

    if (!precalculatedExists)
    {
        // Step 3: Refine the positions of surface points
        double magneticMoment = dipolemoment;  // Magnitude of the magnetic moment

        // Precalculate the field generated by all surface points for all recorded points' space coordinates
        cout<<"Precalculating fields ... \n";

        for (const SurfacePoint& surfacePoint : surfacePoints)
        {
            for (size_t j = 0; j < recordedPoints.size(); ++j)
            {
                const DataPoint& recordedPoint = recordedPoints[j];
                precalculatedFields[j] += computePointField(surfacePoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z));
            }
        }
        cout<<"Reconstruction of the fields done.\n";
        // Write precalculated fields to file for future use
        writePrecalculatedFieldsToFile(precalculatedFilename, precalculatedFields);
    }


    for (size_t i = 0; i < recordedPoints.size(); ++i)          // Account for the surfacepoints influence

        recordedPoints[i].intensity-=precalculatedFields[i];

    cout<<"\n";

    double minscale=0.000001, maxscale=0.1, speed=0.1;

    for(double scale=maxscale ; scale>=minscale; scale*=speed)
    {
        auto startTime = std::chrono::high_resolution_clock::now();

        cout<<"--- Iteration "<<log_a_to_base_b(speed,scale/maxscale)+1<<" out of "<<log_a_to_base_b(speed,minscale/maxscale)+1<<" ---\n";
        cout<<"Starting changeability matrix calculation\n";

        // Changeability matrix and others needed for its accurate calculation
        std::vector<std::bitset<recordsize>> changeability(surfacePoints.size());
        bitset<recordsize> changeabilityver;
        int first[recordsize]= {0};

        // Make a copy of precalculatefields, surfacepoints, and recordedpoints
        std::vector<SurfacePoint> surfacePoints2 = surfacePoints;
        std::vector<DataPoint> recordedPoints2 = recordedPoints;
        std::vector<double> precalculatedFields2 = precalculatedFields;

        for(size_t i=0 ; i< surfacePoints.size(); i++) changeability[i].reset();

        // Calculate changeability matrix
        bool isModified = true;
        while (isModified)
        {
            for (size_t i = 0; i < surfacePoints2.size(); ++i)
            {
                SurfacePoint& surfacePoint = surfacePoints2[i];
                SurfacePoint originalPoint = surfacePoint;
                if (std::isfinite(surfacePoint.x) && std::isfinite(surfacePoint.y) && std::isfinite(surfacePoint.z))
                {
                    // Extend the point along its linear equation away from the center
                    surfacePoint.x += scale * surfacePoint.x;
                    surfacePoint.y += scale * surfacePoint.y;
                    surfacePoint.z += scale * surfacePoint.z;

                    if(isinsiderecorded)
                    {
                        isModified=false;
                        break;
                    }

                    // Compare the computed fields and update the position if necessary
                    vector<double> modifiedIntensities(recordedPoints2.size());
                    vector<double> originalIntensities(recordedPoints2.size());

                    for (size_t j = 0; j < recordedPoints2.size(); ++j)
                    {
                        DataPoint& recordedPoint = recordedPoints2[j];
                        originalIntensities[j] = computePointField(originalPoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z));
                        modifiedIntensities[j] = computePointField(surfacePoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z)) - originalIntensities[j] + precalculatedFields2[j];

                        if (Signchange)
                        {
                            if(!changeabilityver[j]) changeabilityver[j]=1,first[j]=i;
                            else if(!changeability[i][j]) changeability[first[j]][j]=1, changeability[i][j]=1;
                        }
                    }

                    for (size_t j = 0; j < recordedPoints2.size(); ++j)
                    {
                        // Subtract the field caused by the new position of the point from all the measurements
                        recordedPoints2[j].intensity = recordedPoints2[j].intensity - (modifiedIntensities[j] - precalculatedFields2[j] + originalIntensities[j]);

                        // Update the precalculated field generated by all surface points for all recorded points space coordinates
                        precalculatedFields2[j] = modifiedIntensities[j];
                    }


                }

            }

        }


        string refinedPointsFilename = "isitsmall.ply";
        writeRefinedPointsToPLY(refinedPointsFilename, surfacePoints);


        cout<<"Matrix finished. Saving overall changeability for faster reconstruction speeds...\n";

        changeabilityver.reset();      // Reset variable for reuse

        for(size_t j=0; j<recordsize; j++)      //Save overall changeability for faster speeds until surface points are fixed
        {
            bool cnt=false;
            for(size_t i=0 ; i<surfacePoints2.size() ; i++)
            {
                if(changeability[i][j])
                {
                    cnt=true;
                    break;
                }
            }
            if(cnt==true) changeabilityver[j]=1;
        }


        cout<<"Changeability saved\n\n";

        cout<<"Starting magnet reconstruction through surface integration with a scale value of "<<scale<<" ...\n";

        // Step 3: Refine the positions of surface points

        vector<bool> state(surfacePoints.size(), false);  // Initialize state vector with all dipoles as active
        isModified = true;  // Start with isModified as true to enter the loop

        int dips=0;

        bitset<recordsize> verification;
        verification.set();

        cout<<"Fixing constantly influenced measurements in place... \n";

        while (isModified)          // Fixing the non sign changing points for easier calculations that will come
        {
            isModified = false;

            for (size_t i = 0; i < surfacePoints.size(); ++i)
            {
                if (state[i]) continue;  // Skip the stopped dipoles

                SurfacePoint& surfacePoint = surfacePoints[i];
                SurfacePoint originalPoint = surfacePoint;

                if(isinsiderecorded)
                {
                    cout<<"Initial radius too big! It must fit inside all the recorded points!\nReconstruction failed!\n";
                    return 1;
                }

                if (std::isfinite(surfacePoint.x) && std::isfinite(surfacePoint.y) && std::isfinite(surfacePoint.z))
                {
                    // Extend the point along its linear equation away from the center
                    surfacePoint.x += scale * surfacePoint.x;
                    surfacePoint.y += scale * surfacePoint.y;
                    surfacePoint.z += scale * surfacePoint.z;

                    if(isinsiderecorded)
                    {
                        surfacePoint = originalPoint;
                        continue;                       /// Should be break but we don't have data from all around the shape
                    }

                    // Compare the computed fields and update the position if necessary
                    bool isSignChanged = false;
                    vector<double> modifiedIntensities(recordedPoints.size());
                    vector<double> originalIntensities(recordedPoints.size());

                    for (size_t j = 0; j < recordedPoints.size(); ++j)
                    {
                        DataPoint& recordedPoint = recordedPoints[j];
                        originalIntensities[j] = computePointField(originalPoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z));
                        modifiedIntensities[j] = computePointField(surfacePoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z)) - originalIntensities[j] + precalculatedFields[j];

                        if (compareBitsets(verification,changeabilityver) == 1)        // If there still are fixed points uncalculated yet
                        {
                            if(!changeabilityver[j] && recordedPoint.intensity * modifiedIntensities[j] > 0)   // If we have the same sign and a fixed point
                            {
                                if(!Signchange) ;       // Sign didn't change
                                else
                                {
                                    state[i]=true;
                                    verification[j]=0;
                                    isSignChanged=true;
                                    dips++;
                                }
                            }
                            else ;  // It is not a fixed point, we continue with the calculations

                        }
                        else
                        {
                            isModified=false;
                            break;
                        }

                    }

                    if (isSignChanged)
                    {
                        surfacePoint = originalPoint;
                        continue;
                    }

                    else
                    {
                        isModified = true;

                        for (size_t j = 0; j < recordedPoints.size(); ++j)          // Updating the modified fields of the point.
                        {
                            // Subtract the field caused by the new position of the point from all the measurements
                            recordedPoints[j].intensity -= (modifiedIntensities[j] - precalculatedFields[j] + originalIntensities[j]);

                            // Update the precalculated field generated by all surface points for all recorded points space coordinates
                            precalculatedFields[j] = modifiedIntensities[j];
                        }

                    }
                }
            }
        }

        cout<<"Fixing done. Started moving surface points analysis and looking for their most probable distribution.\n ";

        // Step 1: Sort the surface points based on changeability and the number of influenced recorded points
        std::vector<int> surfacePointOrder;
        std::vector<int> sortedSurfacePointIndices;

        int k=0;

        surfacePointOrder.push_back(0), sortedSurfacePointIndices.push_back(0);

        for (size_t i = 0; i < surfacePoints.size(); ++i)
        {
            if(state[i]==false)
            {
                for (size_t j = 0; j < recordsize ; ++j) if (changeability[i][j]) surfacePointOrder[k]++,sortedSurfacePointIndices[k] = i;
                if(surfacePointOrder[k]) surfacePointOrder.push_back(0), sortedSurfacePointIndices.push_back(0), k++;
            }

        }

        std::sort(sortedSurfacePointIndices.begin(), sortedSurfacePointIndices.end(), [&](int a, int b)
        {
            return surfacePointOrder[a] < surfacePointOrder[b];
        });

        k=0;
        std::vector<int> recordedPointOrder;
        std::vector<int> sortedrecordedPointIndices;


        recordedPointOrder.push_back(0),sortedrecordedPointIndices.push_back(0);

        for (size_t i = 0; i < recordsize; ++i)
        {
            for (size_t j = 0; j < surfacePoints.size(); ++j)
            {
                if(state[j]==false) if (changeability[j][i]) recordedPointOrder[k]++, sortedrecordedPointIndices[k] = i;
            }
            if(recordedPointOrder[k]) recordedPointOrder.push_back(0),sortedrecordedPointIndices.push_back(0), k++;
        }


        std::sort(sortedrecordedPointIndices.begin(), sortedrecordedPointIndices.end(), [&](int a, int b)
        {
            return recordedPointOrder[a] < recordedPointOrder[b];
        });


        bitset <recordsize> surfaceOrder;
        bitset <recordsize> surfaceOrder2;

        k=0;
        std::vector<int> surfacePointfinalOrder;


        for(size_t i=0; i< sortedrecordedPointIndices.size(); i++)
        {
            for(size_t j=0; j<surfacePoints.size(); j++) if(changeability[j][sortedrecordedPointIndices[i]] && state[j]==false) surfaceOrder[j]=1;
            cout<<i;
            for(size_t l=0; l<sortedSurfacePointIndices.size(); l++) if(surfaceOrder[sortedSurfacePointIndices[l]]==1) surfaceOrder[l]=0, surfacePointfinalOrder[k++]=l;
        }


        surfaceOrder.reset();

        for(size_t i=0 ; i < surfacePointfinalOrder.size(); i++)
            if(!surfaceOrder[surfacePointfinalOrder[i]] && !surfaceOrder2[surfacePointfinalOrder[i]]) surfaceOrder2[surfacePointfinalOrder[i]]=1;
            else surfaceOrder[surfacePointfinalOrder[i]]=1, surfacePointfinalOrder[i]=-1;



        cout<<"Successfully calculated the importance of the moving SurfacePoints. \n";
        cout<<"Starting refining the remaining ones...\n";

        isModified=true;
        while (isModified)
        {
            isModified = false;

            for (auto& recordedIndex : sortedrecordedPointIndices)
            {
                if(!verification[recordedIndex]) continue;

                auto& recordedPoint = recordedPoints[recordedIndex];

                for (auto& surfaceIndex : surfacePointfinalOrder)
                {

                    if(surfaceIndex==-1) continue;
                    auto& surfacePoint = surfacePoints[surfaceIndex];

                    SurfacePoint originalPoint = surfacePoint;

                    if (std::isfinite(surfacePoint.x) && std::isfinite(surfacePoint.y) && std::isfinite(surfacePoint.z))
                    {
                        surfacePoint.x += scale * surfacePoint.x;
                        surfacePoint.y += scale * surfacePoint.y;
                        surfacePoint.z += scale * surfacePoint.z;

                        if(isinsiderecorded)
                        {
                            surfacePoint = originalPoint;
                            continue;                       /// Should be break but we don't have data from all around the shape
                        }

                        double modifiedIntensity;
                        double originalIntensity;

                        auto& recordedPoint = recordedPoints[recordedIndex];
                        originalIntensity = computePointField(originalPoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z));
                        modifiedIntensity = computePointField(surfacePoint, Eigen::Vector3d(recordedPoint.x, recordedPoint.y, recordedPoint.z)) - originalIntensity + precalculatedFields[recordedIndex];

                        if (!((recordedPoint.intensity > 0 && recordedPoint.intensity < modifiedIntensity) || (recordedPoint.intensity < 0 && recordedPoint.intensity > modifiedIntensity)) && modifiedIntensity * recordedPoint.intensity > 0)
                        {
                            verification[recordedIndex]=0;
                            surfaceOrder.reset();

                            for(size_t i=0; i< surfacePoints.size(); i++) if(changeability[i][recordedIndex]) surfaceOrder[surfaceIndex]=1;

                            for(size_t i=0; i< surfacePoints.size(); i++) if(surfaceOrder[i]) sortedrecordedPointIndices[i]=-1;
                            surfacePoint = originalPoint;
                            break;
                        }

                        else
                        {
                            // Subtract the field caused by the new position of the point from all the measurements
                            recordedPoints[recordedIndex].intensity = recordedPoints[recordedIndex].intensity - (modifiedIntensity- precalculatedFields[recordedIndex] + originalIntensity);

                            // Update the precalculated field generated by all surface points for all recorded points space coordinates
                            precalculatedFields[recordedIndex] = modifiedIntensity;
                            isModified=true;
                        }


                    }
                }
            }
        }
        refinedPointsFilename = "refined_points.ply";
        writeRefinedPointsToPLY(refinedPointsFilename, surfacePoints);

        auto endTime = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> duration = endTime - startTime;

        cout<<"Points refined, decreasing scale.\n\n";
        cout<<"-> Iteration took "<<duration.count()<<" seconds or "<<duration.count()/60<<" minutes";
        cout<<"\n\n\n";


        cout<<"Everything's fine ";

    }

    std::cout<<"Reconstruction finished. Outputing points...\n";


    string refinedPointsFilename = "refined_points.ply";
    writeRefinedPointsToPLY(refinedPointsFilename, surfacePoints);
    cout<<"Shape saved to 'refined_points.ply' succesfully.\n";

    return 0;
}
